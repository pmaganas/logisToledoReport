"""
Controlador para gestión de conexiones API
"""
from typing import Dict, Any, Optional, Tuple
from flask import request, render_template, jsonify

from models import SesameToken
from models.responses import ResponseBuilder, TokenInfo
from services.api_factory import APIFactory, connection_manager
from services.check_types_service import CheckTypesService
from utils.decorators import handle_api_errors, requires_active_token
from utils.validators import TokenValidator, RegionValidator
from utils.logging_config import get_logger
from exceptions import ValidationError, APIError
from app import db


class ConnectionController:
    """Controlador para manejo de conexiones API"""
    
    def __init__(self):
        self.logger = get_logger(__name__)
        self.api_factory = APIFactory
        self.check_types_service = CheckTypesService()
    
    def show_connection_page(self):
        """
        Mostrar página de configuración de conexión
        
        Returns:
            Template renderizado
        """
        return render_template('connection.html')
    
    @handle_api_errors
    def apply_token(self):
        """
        Aplicar nuevo token de API
        
        Returns:
            JSON response
        """
        try:
            data = request.get_json() or {}
            
            # Validar datos de entrada
            raw_token = data.get('token', '').strip()
            region = data.get('region', 'eu1').strip()
            description = data.get('description', '').strip()
            
            # Validar token
            validated_token = TokenValidator.validate_token(raw_token)
            validated_region = RegionValidator.validate_region(region)
            
            self.logger.info(f"Aplicando nuevo token con región: {validated_region}\")\n            \n            # Guardar token en base de datos\n            SesameToken.set_active_token(\n                token=validated_token,\n                description=description,\n                region=validated_region\n            )\n            \n            # Limpiar cache de APIs para forzar recreación con nuevo token\n            self.api_factory.clear_cache()\n            \n            # Probar conexión con el nuevo token\n            test_result = self.test_connection()\n            \n            if test_result.get('success', False):\n                # Sincronizar tipos de actividad en background\n                try:\n                    self.check_types_service.sync_check_types()\n                    self.logger.info(\"Tipos de actividad sincronizados después de configurar token\")\n                except Exception as e:\n                    self.logger.warning(f\"Error sincronizando tipos de actividad: {str(e)}\")\n                \n                company_name = test_result.get('data', {}).get('company', {}).get('name', 'Empresa no identificada')\n                \n                response = ResponseBuilder.success(\n                    \"Token aplicado correctamente\",\n                    data={\n                        'company': company_name,\n                        'region': validated_region,\n                        'description': description\n                    }\n                )\n                \n                self.logger.info(f\"Token configurado exitosamente para empresa: {company_name}\")\n                return jsonify(response.to_dict())\n            else:\n                # El token se guardó pero la conexión falló\n                error_msg = test_result.get('message', 'No se pudo verificar la conexión')\n                self.logger.error(f\"Token guardado pero conexión falló: {error_msg}\")\n                \n                response = ResponseBuilder.error(\n                    f\"Token guardado pero hay problemas de conexión: {error_msg}\",\n                    error_code=\"TOKEN_CONNECTION_WARNING\"\n                )\n                return jsonify(response.to_dict()), 400\n                \n        except ValidationError as e:\n            self.logger.warning(f\"Error de validación en apply_token: {e.message}\")\n            response = ResponseBuilder.validation_error(e.message, field=e.field, details=e.details)\n            return jsonify(response.to_dict()), 422\n            \n        except Exception as e:\n            self.logger.error(f\"Error aplicando token: {str(e)}\")\n            response = ResponseBuilder.error(\n                f\"Error al aplicar el token: {str(e)}\",\n                error_code=\"TOKEN_APPLICATION_ERROR\"\n            )\n            return jsonify(response.to_dict()), 500\n    \n    @handle_api_errors\n    def test_connection(self) -> Dict[str, Any]:\n        \"\"\"\n        Probar conexión con la API\n        \n        Returns:\n            Diccionario con resultado de la prueba\n        \"\"\"\n        try:\n            # Usar el gestor de conexiones\n            result = connection_manager.test_connection()\n            \n            if result.get('success', False):\n                # Intentar sincronizar tipos de actividad como verificación adicional\n                try:\n                    self.check_types_service.ensure_check_types_cached()\n                except Exception as e:\n                    self.logger.warning(f\"Error verificando cache de tipos de actividad: {str(e)}\")\n            \n            return result\n            \n        except Exception as e:\n            self.logger.error(f\"Error probando conexión: {str(e)}\")\n            return {\n                'success': False,\n                'message': f\"Error de conexión: {str(e)}\",\n                'error': str(e)\n            }\n    \n    @handle_api_errors\n    def test_connection_endpoint(self):\n        \"\"\"\n        Endpoint para probar conexión API\n        \n        Returns:\n            JSON response\n        \"\"\"\n        result = self.test_connection()\n        \n        if result.get('success', False):\n            company_name = \"Empresa no identificada\"\n            \n            api_data = result.get('data', {})\n            if 'data' in api_data and 'company' in api_data['data']:\n                company_name = api_data['data']['company'].get('name', company_name)\n            elif 'company' in api_data:\n                company_name = api_data['company'].get('name', company_name)\n            \n            response = ResponseBuilder.api_connection(\n                connected=True,\n                message=\"Conexión exitosa\",\n                company_name=company_name,\n                token_info=api_data\n            )\n        else:\n            response = ResponseBuilder.api_connection(\n                connected=False,\n                message=result.get('message', 'No se pudo conectar a la API')\n            )\n        \n        status_code = 200 if result.get('success', False) else 500\n        return jsonify(response.to_dict()), status_code\n    \n    @handle_api_errors\n    def remove_connection(self):\n        \"\"\"\n        Remover conexión actual\n        \n        Returns:\n            JSON response\n        \"\"\"\n        try:\n            from models import CheckType\n            \n            # Remover todos los tokens\n            SesameToken.remove_all_tokens()\n            \n            # Limpiar cache de tipos de actividad\n            CheckType.query.delete()\n            db.session.commit()\n            \n            # Limpiar cache de APIs\n            self.api_factory.clear_cache()\n            \n            self.logger.info(\"Conexión removida exitosamente\")\n            \n            response = ResponseBuilder.success(\n                \"Conexión cerrada correctamente. Se han eliminado todos los tokens y datos asociados.\"\n            )\n            \n            return jsonify(response.to_dict())\n            \n        except Exception as e:\n            self.logger.error(f\"Error removiendo conexión: {str(e)}\")\n            response = ResponseBuilder.error(\n                f\"Error al cerrar la conexión: {str(e)}\",\n                error_code=\"CONNECTION_REMOVAL_ERROR\"\n            )\n            return jsonify(response.to_dict()), 500\n    \n    @handle_api_errors\n    def get_current_token(self):\n        \"\"\"\n        Obtener información del token actual\n        \n        Returns:\n            JSON response\n        \"\"\"\n        try:\n            token_record = SesameToken.get_active_token()\n            \n            if not token_record:\n                response = ResponseBuilder.token_info(\n                    has_token=False,\n                    message=\"No hay token configurado\"\n                )\n                return jsonify(response.to_dict())\n            \n            # Obtener información de la empresa desde la API\n            company_name = \"Empresa no identificada\"\n            try:\n                test_result = self.test_connection()\n                if test_result.get('success', False):\n                    api_data = test_result.get('data', {})\n                    if 'data' in api_data and 'company' in api_data['data']:\n                        company_name = api_data['data']['company'].get('name', company_name)\n                    elif 'company' in api_data:\n                        company_name = api_data['company'].get('name', company_name)\n            except Exception as e:\n                self.logger.warning(f\"Error obteniendo información de empresa: {str(e)}\")\n            \n            # Enmascarar token para seguridad\n            masked_token = self._mask_token(token_record.token)\n            \n            token_info = TokenInfo(\n                masked_token=masked_token,\n                region=token_record.region,\n                description=token_record.description,\n                created_at=token_record.created_at,\n                company_name=company_name\n            )\n            \n            response = ResponseBuilder.token_info(\n                has_token=True,\n                token_info=token_info,\n                message=\"Información de token obtenida\"\n            )\n            \n            return jsonify(response.to_dict())\n            \n        except Exception as e:\n            self.logger.error(f\"Error obteniendo token actual: {str(e)}\")\n            response = ResponseBuilder.error(\n                f\"Error al obtener información del token: {str(e)}\",\n                error_code=\"TOKEN_INFO_ERROR\"\n            )\n            return jsonify(response.to_dict()), 500\n    \n    @handle_api_errors\n    def refresh_check_types(self):\n        \"\"\"\n        Refrescar tipos de actividad desde la API\n        \n        Returns:\n            JSON response\n        \"\"\"\n        try:\n            result = self.check_types_service.refresh_check_types()\n            \n            if result:\n                response = ResponseBuilder.success(\n                    \"Tipos de fichajes actualizados correctamente\"\n                )\n                return jsonify(response.to_dict())\n            else:\n                response = ResponseBuilder.error(\n                    \"Error al actualizar tipos de fichajes\",\n                    error_code=\"CHECK_TYPES_REFRESH_ERROR\"\n                )\n                return jsonify(response.to_dict()), 500\n                \n        except Exception as e:\n            self.logger.error(f\"Error refrescando tipos de actividad: {str(e)}\")\n            response = ResponseBuilder.error(\n                f\"Error al actualizar tipos de fichajes: {str(e)}\",\n                error_code=\"CHECK_TYPES_REFRESH_ERROR\"\n            )\n            return jsonify(response.to_dict()), 500\n    \n    def _mask_token(self, token: str) -> str:\n        \"\"\"\n        Enmascarar token para mostrar de forma segura\n        \n        Args:\n            token: Token completo\n            \n        Returns:\n            Token enmascarado\n        \"\"\"\n        if len(token) <= 12:\n            return '*' * len(token)\n        \n        return token[:8] + '*' * (len(token) - 12) + token[-4:]\n\n\n# Instancia global del controlador de conexión\nconnection_controller = ConnectionController()"}, {"old_string": "            self.logger.info(f\"Aplicando nuevo token con región: {validated_region}\")", "new_string": "            self.logger.info(f\"Aplicando nuevo token con región: {validated_region}\")"}]